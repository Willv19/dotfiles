# Adapted from https://github.com/LukeSmithxyz/voidrice/blob/master/.config/lf/lfrc
# and lfrc.example

# Set custom options
set shell zsh
set shellopts '-eu:--shwordsplit' # Fix issues with word splitting in zsh
set ifs "\n"
set scrolloff 10
set icons
set period 1

# Use my `scope` script for previews. We then reload to refresh the first preview.
$lf -remote "send $id set previewer ${XDG_CONFIG_HOME:-$HOME/.config}/lf/scope"
$lf -remote "send $id reload"

#
# Define new commands
#

# Vim muscle memory
cmd q quit

# define a custom 'open' command
cmd open $~/.config/lf/opener

# move current file or selected files to trash folder
cmd trash %trash $fx

cmd mkdir %mkdir $@

# compress current file or selected files with tar and gzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}

# Rename a bunch of files at once in vim
cmd bulkrename $echo "$fs" | vidir -

# Combine pdfs
cmd combine ${{
    if (( $# >= 1)); then
        filename="$1"
    else
        local tmp="$(mktemp)"
        whiptail --inputbox 'Filename:' 8 25 2> "$tmp"
        filename="$(cat $tmp)"
        rm "$tmp"
    fi

    set -f
    echo "$fs" | while read -r line; do
        # Usually we are combining files downloaded from my scanner, which
        # names them document.pdf. Firefox then renames duplicates
        # document(n).pdf. This orchestration puts the files in the proper
        # order so that I don't have to re-order them when I just want to
        # combine a bunch of pages I just scanned.
        if [[ "$line" =~ '.*document\(([0-9]+)\).pdf\s*$' ]]; then
            num=$match[1]
        elif [[ "$line" =~ '.*document.pdf\s*$' ]]; then
            num=0
        else
            num=1000 # We want these at the end
        fi
        echo "$num	'$line'	1-z"
    done \
    | sort -n \
    | awk '{ $1 = ""; print $0 }' \
    | vipe \
    | xargs -t sh -c 'qpdf --empty --pages "$@" -- "'"$filename"'"' --
}}

#
# Bind keys
#

# Bind keys to my new commands
map D trash
map B bulkrename

# Use fzf to jump around
map <c-f> $lf -remote "send $id select '$(fzf)'"
map J $lf -remote "send $id cd '$(cut -d',' -f2 $HOME/.config/directories | fzf)'"

# Lots of ways to rename
map A rename # at the very end
map a push A<a-b><c-b> # before the extension
map C push A<a-b><c-b><c-u> # new rename
map I push A<c-a> # at the very beginning

# ZLE
cmd zle-cd %printf 'cd %q && zle reset-prompt\n' "$PWD" >&$ZLE_FIFO

cmd zle-tmux-cwd %printf 'tmux-cwd %q\n' "$PWD" >&$ZLE_FIFO

cmd zle-insert-relative %{{
    for f in $fx; do
        printf 'LBUFFER+="${LBUFFER:+ }${(q)$(realpath %q --relative-to=$PWD)}"\n' "$f" >&$ZLE_FIFO
    done
}}

cmd zle-insert-absolute %{{
    for f in $fx; do
        printf 'LBUFFER+="${LBUFFER:+ }%q"\n' "$f" >&$ZLE_FIFO
    done
}}

cmd zle-init :{{
    map . zle-cd
    map t zle-tmux-cwd
    map a zle-insert-relative
    map A zle-insert-absolute
}}

&[[ -n "$ZLE_FIFO" ]] && lf -remote "send $id zle-init"
